// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'auth_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AuthConfigTearOff {
  const _$AuthConfigTearOff();

  _AuthConfig call(
      {Widget? title,
      ButtonConfig? signInButton,
      ButtonConfig? registerButton,
      ButtonConfig? anonymousButton,
      GoogleButtonConfig? googleButton,
      AppleButtonConfig? appleButton,
      ButtonConfig? githubButton,
      ButtonConfig? twitterButton,
      TextFieldConfig? emailTextField,
      TextFieldConfig? passwordTextField}) {
    return _AuthConfig(
      title: title,
      signInButton: signInButton,
      registerButton: registerButton,
      anonymousButton: anonymousButton,
      googleButton: googleButton,
      appleButton: appleButton,
      githubButton: githubButton,
      twitterButton: twitterButton,
      emailTextField: emailTextField,
      passwordTextField: passwordTextField,
    );
  }
}

/// @nodoc
const $AuthConfig = _$AuthConfigTearOff();

/// @nodoc
mixin _$AuthConfig {
  Widget? get title => throw _privateConstructorUsedError;
  ButtonConfig? get signInButton => throw _privateConstructorUsedError;
  ButtonConfig? get registerButton => throw _privateConstructorUsedError;
  ButtonConfig? get anonymousButton => throw _privateConstructorUsedError;
  GoogleButtonConfig? get googleButton => throw _privateConstructorUsedError;
  AppleButtonConfig? get appleButton => throw _privateConstructorUsedError;
  ButtonConfig? get githubButton => throw _privateConstructorUsedError;
  ButtonConfig? get twitterButton => throw _privateConstructorUsedError;
  TextFieldConfig? get emailTextField => throw _privateConstructorUsedError;
  TextFieldConfig? get passwordTextField => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AuthConfigCopyWith<AuthConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthConfigCopyWith<$Res> {
  factory $AuthConfigCopyWith(
          AuthConfig value, $Res Function(AuthConfig) then) =
      _$AuthConfigCopyWithImpl<$Res>;
  $Res call(
      {Widget? title,
      ButtonConfig? signInButton,
      ButtonConfig? registerButton,
      ButtonConfig? anonymousButton,
      GoogleButtonConfig? googleButton,
      AppleButtonConfig? appleButton,
      ButtonConfig? githubButton,
      ButtonConfig? twitterButton,
      TextFieldConfig? emailTextField,
      TextFieldConfig? passwordTextField});

  $ButtonConfigCopyWith<$Res>? get signInButton;
  $ButtonConfigCopyWith<$Res>? get registerButton;
  $ButtonConfigCopyWith<$Res>? get anonymousButton;
  $GoogleButtonConfigCopyWith<$Res>? get googleButton;
  $AppleButtonConfigCopyWith<$Res>? get appleButton;
  $ButtonConfigCopyWith<$Res>? get githubButton;
  $ButtonConfigCopyWith<$Res>? get twitterButton;
}

/// @nodoc
class _$AuthConfigCopyWithImpl<$Res> implements $AuthConfigCopyWith<$Res> {
  _$AuthConfigCopyWithImpl(this._value, this._then);

  final AuthConfig _value;
  // ignore: unused_field
  final $Res Function(AuthConfig) _then;

  @override
  $Res call({
    Object? title = freezed,
    Object? signInButton = freezed,
    Object? registerButton = freezed,
    Object? anonymousButton = freezed,
    Object? googleButton = freezed,
    Object? appleButton = freezed,
    Object? githubButton = freezed,
    Object? twitterButton = freezed,
    Object? emailTextField = freezed,
    Object? passwordTextField = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as Widget?,
      signInButton: signInButton == freezed
          ? _value.signInButton
          : signInButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      registerButton: registerButton == freezed
          ? _value.registerButton
          : registerButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      anonymousButton: anonymousButton == freezed
          ? _value.anonymousButton
          : anonymousButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      googleButton: googleButton == freezed
          ? _value.googleButton
          : googleButton // ignore: cast_nullable_to_non_nullable
              as GoogleButtonConfig?,
      appleButton: appleButton == freezed
          ? _value.appleButton
          : appleButton // ignore: cast_nullable_to_non_nullable
              as AppleButtonConfig?,
      githubButton: githubButton == freezed
          ? _value.githubButton
          : githubButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      twitterButton: twitterButton == freezed
          ? _value.twitterButton
          : twitterButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      emailTextField: emailTextField == freezed
          ? _value.emailTextField
          : emailTextField // ignore: cast_nullable_to_non_nullable
              as TextFieldConfig?,
      passwordTextField: passwordTextField == freezed
          ? _value.passwordTextField
          : passwordTextField // ignore: cast_nullable_to_non_nullable
              as TextFieldConfig?,
    ));
  }

  @override
  $ButtonConfigCopyWith<$Res>? get signInButton {
    if (_value.signInButton == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.signInButton!, (value) {
      return _then(_value.copyWith(signInButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res>? get registerButton {
    if (_value.registerButton == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.registerButton!, (value) {
      return _then(_value.copyWith(registerButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res>? get anonymousButton {
    if (_value.anonymousButton == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.anonymousButton!, (value) {
      return _then(_value.copyWith(anonymousButton: value));
    });
  }

  @override
  $GoogleButtonConfigCopyWith<$Res>? get googleButton {
    if (_value.googleButton == null) {
      return null;
    }

    return $GoogleButtonConfigCopyWith<$Res>(_value.googleButton!, (value) {
      return _then(_value.copyWith(googleButton: value));
    });
  }

  @override
  $AppleButtonConfigCopyWith<$Res>? get appleButton {
    if (_value.appleButton == null) {
      return null;
    }

    return $AppleButtonConfigCopyWith<$Res>(_value.appleButton!, (value) {
      return _then(_value.copyWith(appleButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res>? get githubButton {
    if (_value.githubButton == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.githubButton!, (value) {
      return _then(_value.copyWith(githubButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res>? get twitterButton {
    if (_value.twitterButton == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.twitterButton!, (value) {
      return _then(_value.copyWith(twitterButton: value));
    });
  }
}

/// @nodoc
abstract class _$AuthConfigCopyWith<$Res> implements $AuthConfigCopyWith<$Res> {
  factory _$AuthConfigCopyWith(
          _AuthConfig value, $Res Function(_AuthConfig) then) =
      __$AuthConfigCopyWithImpl<$Res>;
  @override
  $Res call(
      {Widget? title,
      ButtonConfig? signInButton,
      ButtonConfig? registerButton,
      ButtonConfig? anonymousButton,
      GoogleButtonConfig? googleButton,
      AppleButtonConfig? appleButton,
      ButtonConfig? githubButton,
      ButtonConfig? twitterButton,
      TextFieldConfig? emailTextField,
      TextFieldConfig? passwordTextField});

  @override
  $ButtonConfigCopyWith<$Res>? get signInButton;
  @override
  $ButtonConfigCopyWith<$Res>? get registerButton;
  @override
  $ButtonConfigCopyWith<$Res>? get anonymousButton;
  @override
  $GoogleButtonConfigCopyWith<$Res>? get googleButton;
  @override
  $AppleButtonConfigCopyWith<$Res>? get appleButton;
  @override
  $ButtonConfigCopyWith<$Res>? get githubButton;
  @override
  $ButtonConfigCopyWith<$Res>? get twitterButton;
}

/// @nodoc
class __$AuthConfigCopyWithImpl<$Res> extends _$AuthConfigCopyWithImpl<$Res>
    implements _$AuthConfigCopyWith<$Res> {
  __$AuthConfigCopyWithImpl(
      _AuthConfig _value, $Res Function(_AuthConfig) _then)
      : super(_value, (v) => _then(v as _AuthConfig));

  @override
  _AuthConfig get _value => super._value as _AuthConfig;

  @override
  $Res call({
    Object? title = freezed,
    Object? signInButton = freezed,
    Object? registerButton = freezed,
    Object? anonymousButton = freezed,
    Object? googleButton = freezed,
    Object? appleButton = freezed,
    Object? githubButton = freezed,
    Object? twitterButton = freezed,
    Object? emailTextField = freezed,
    Object? passwordTextField = freezed,
  }) {
    return _then(_AuthConfig(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as Widget?,
      signInButton: signInButton == freezed
          ? _value.signInButton
          : signInButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      registerButton: registerButton == freezed
          ? _value.registerButton
          : registerButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      anonymousButton: anonymousButton == freezed
          ? _value.anonymousButton
          : anonymousButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      googleButton: googleButton == freezed
          ? _value.googleButton
          : googleButton // ignore: cast_nullable_to_non_nullable
              as GoogleButtonConfig?,
      appleButton: appleButton == freezed
          ? _value.appleButton
          : appleButton // ignore: cast_nullable_to_non_nullable
              as AppleButtonConfig?,
      githubButton: githubButton == freezed
          ? _value.githubButton
          : githubButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      twitterButton: twitterButton == freezed
          ? _value.twitterButton
          : twitterButton // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
      emailTextField: emailTextField == freezed
          ? _value.emailTextField
          : emailTextField // ignore: cast_nullable_to_non_nullable
              as TextFieldConfig?,
      passwordTextField: passwordTextField == freezed
          ? _value.passwordTextField
          : passwordTextField // ignore: cast_nullable_to_non_nullable
              as TextFieldConfig?,
    ));
  }
}

/// @nodoc

class _$_AuthConfig with DiagnosticableTreeMixin implements _AuthConfig {
  const _$_AuthConfig(
      {this.title,
      this.signInButton,
      this.registerButton,
      this.anonymousButton,
      this.googleButton,
      this.appleButton,
      this.githubButton,
      this.twitterButton,
      this.emailTextField,
      this.passwordTextField});

  @override
  final Widget? title;
  @override
  final ButtonConfig? signInButton;
  @override
  final ButtonConfig? registerButton;
  @override
  final ButtonConfig? anonymousButton;
  @override
  final GoogleButtonConfig? googleButton;
  @override
  final AppleButtonConfig? appleButton;
  @override
  final ButtonConfig? githubButton;
  @override
  final ButtonConfig? twitterButton;
  @override
  final TextFieldConfig? emailTextField;
  @override
  final TextFieldConfig? passwordTextField;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AuthConfig(title: $title, signInButton: $signInButton, registerButton: $registerButton, anonymousButton: $anonymousButton, googleButton: $googleButton, appleButton: $appleButton, githubButton: $githubButton, twitterButton: $twitterButton, emailTextField: $emailTextField, passwordTextField: $passwordTextField)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AuthConfig'))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('signInButton', signInButton))
      ..add(DiagnosticsProperty('registerButton', registerButton))
      ..add(DiagnosticsProperty('anonymousButton', anonymousButton))
      ..add(DiagnosticsProperty('googleButton', googleButton))
      ..add(DiagnosticsProperty('appleButton', appleButton))
      ..add(DiagnosticsProperty('githubButton', githubButton))
      ..add(DiagnosticsProperty('twitterButton', twitterButton))
      ..add(DiagnosticsProperty('emailTextField', emailTextField))
      ..add(DiagnosticsProperty('passwordTextField', passwordTextField));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AuthConfig &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.signInButton, signInButton) ||
                const DeepCollectionEquality()
                    .equals(other.signInButton, signInButton)) &&
            (identical(other.registerButton, registerButton) ||
                const DeepCollectionEquality()
                    .equals(other.registerButton, registerButton)) &&
            (identical(other.anonymousButton, anonymousButton) ||
                const DeepCollectionEquality()
                    .equals(other.anonymousButton, anonymousButton)) &&
            (identical(other.googleButton, googleButton) ||
                const DeepCollectionEquality()
                    .equals(other.googleButton, googleButton)) &&
            (identical(other.appleButton, appleButton) ||
                const DeepCollectionEquality()
                    .equals(other.appleButton, appleButton)) &&
            (identical(other.githubButton, githubButton) ||
                const DeepCollectionEquality()
                    .equals(other.githubButton, githubButton)) &&
            (identical(other.twitterButton, twitterButton) ||
                const DeepCollectionEquality()
                    .equals(other.twitterButton, twitterButton)) &&
            (identical(other.emailTextField, emailTextField) ||
                const DeepCollectionEquality()
                    .equals(other.emailTextField, emailTextField)) &&
            (identical(other.passwordTextField, passwordTextField) ||
                const DeepCollectionEquality()
                    .equals(other.passwordTextField, passwordTextField)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(signInButton) ^
      const DeepCollectionEquality().hash(registerButton) ^
      const DeepCollectionEquality().hash(anonymousButton) ^
      const DeepCollectionEquality().hash(googleButton) ^
      const DeepCollectionEquality().hash(appleButton) ^
      const DeepCollectionEquality().hash(githubButton) ^
      const DeepCollectionEquality().hash(twitterButton) ^
      const DeepCollectionEquality().hash(emailTextField) ^
      const DeepCollectionEquality().hash(passwordTextField);

  @JsonKey(ignore: true)
  @override
  _$AuthConfigCopyWith<_AuthConfig> get copyWith =>
      __$AuthConfigCopyWithImpl<_AuthConfig>(this, _$identity);
}

abstract class _AuthConfig implements AuthConfig {
  const factory _AuthConfig(
      {Widget? title,
      ButtonConfig? signInButton,
      ButtonConfig? registerButton,
      ButtonConfig? anonymousButton,
      GoogleButtonConfig? googleButton,
      AppleButtonConfig? appleButton,
      ButtonConfig? githubButton,
      ButtonConfig? twitterButton,
      TextFieldConfig? emailTextField,
      TextFieldConfig? passwordTextField}) = _$_AuthConfig;

  @override
  Widget? get title => throw _privateConstructorUsedError;
  @override
  ButtonConfig? get signInButton => throw _privateConstructorUsedError;
  @override
  ButtonConfig? get registerButton => throw _privateConstructorUsedError;
  @override
  ButtonConfig? get anonymousButton => throw _privateConstructorUsedError;
  @override
  GoogleButtonConfig? get googleButton => throw _privateConstructorUsedError;
  @override
  AppleButtonConfig? get appleButton => throw _privateConstructorUsedError;
  @override
  ButtonConfig? get githubButton => throw _privateConstructorUsedError;
  @override
  ButtonConfig? get twitterButton => throw _privateConstructorUsedError;
  @override
  TextFieldConfig? get emailTextField => throw _privateConstructorUsedError;
  @override
  TextFieldConfig? get passwordTextField => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$AuthConfigCopyWith<_AuthConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ButtonConfigTearOff {
  const _$ButtonConfigTearOff();

  ButtonConfigRaised raised(
      {required ButtonThemeData themedata, required Widget child}) {
    return ButtonConfigRaised(
      themedata: themedata,
      child: child,
    );
  }

  ButtonConfigFlat flat(
      {required ButtonThemeData themedata, required Widget child}) {
    return ButtonConfigFlat(
      themedata: themedata,
      child: child,
    );
  }

  ButtonConfigFlatIcon flatIcon(
      {required ButtonThemeData themedata,
      required Widget icon,
      required Widget child}) {
    return ButtonConfigFlatIcon(
      themedata: themedata,
      icon: icon,
      child: child,
    );
  }

  ButtonConfigRaisedIcon raisedIcon(
      {required ButtonThemeData themedata,
      required Widget icon,
      required Widget child}) {
    return ButtonConfigRaisedIcon(
      themedata: themedata,
      icon: icon,
      child: child,
    );
  }
}

/// @nodoc
const $ButtonConfig = _$ButtonConfigTearOff();

/// @nodoc
mixin _$ButtonConfig {
  ButtonThemeData get themedata => throw _privateConstructorUsedError;
  Widget get child => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ButtonThemeData themedata, Widget child) raised,
    required TResult Function(ButtonThemeData themedata, Widget child) flat,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        flatIcon,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        raisedIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ButtonThemeData themedata, Widget child)? raised,
    TResult Function(ButtonThemeData themedata, Widget child)? flat,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        flatIcon,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        raisedIcon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ButtonConfigRaised value) raised,
    required TResult Function(ButtonConfigFlat value) flat,
    required TResult Function(ButtonConfigFlatIcon value) flatIcon,
    required TResult Function(ButtonConfigRaisedIcon value) raisedIcon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ButtonConfigRaised value)? raised,
    TResult Function(ButtonConfigFlat value)? flat,
    TResult Function(ButtonConfigFlatIcon value)? flatIcon,
    TResult Function(ButtonConfigRaisedIcon value)? raisedIcon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ButtonConfigCopyWith<ButtonConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigCopyWith(
          ButtonConfig value, $Res Function(ButtonConfig) then) =
      _$ButtonConfigCopyWithImpl<$Res>;
  $Res call({ButtonThemeData themedata, Widget child});
}

/// @nodoc
class _$ButtonConfigCopyWithImpl<$Res> implements $ButtonConfigCopyWith<$Res> {
  _$ButtonConfigCopyWithImpl(this._value, this._then);

  final ButtonConfig _value;
  // ignore: unused_field
  final $Res Function(ButtonConfig) _then;

  @override
  $Res call({
    Object? themedata = freezed,
    Object? child = freezed,
  }) {
    return _then(_value.copyWith(
      themedata: themedata == freezed
          ? _value.themedata
          : themedata // ignore: cast_nullable_to_non_nullable
              as ButtonThemeData,
      child: child == freezed
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget,
    ));
  }
}

/// @nodoc
abstract class $ButtonConfigRaisedCopyWith<$Res>
    implements $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigRaisedCopyWith(
          ButtonConfigRaised value, $Res Function(ButtonConfigRaised) then) =
      _$ButtonConfigRaisedCopyWithImpl<$Res>;
  @override
  $Res call({ButtonThemeData themedata, Widget child});
}

/// @nodoc
class _$ButtonConfigRaisedCopyWithImpl<$Res>
    extends _$ButtonConfigCopyWithImpl<$Res>
    implements $ButtonConfigRaisedCopyWith<$Res> {
  _$ButtonConfigRaisedCopyWithImpl(
      ButtonConfigRaised _value, $Res Function(ButtonConfigRaised) _then)
      : super(_value, (v) => _then(v as ButtonConfigRaised));

  @override
  ButtonConfigRaised get _value => super._value as ButtonConfigRaised;

  @override
  $Res call({
    Object? themedata = freezed,
    Object? child = freezed,
  }) {
    return _then(ButtonConfigRaised(
      themedata: themedata == freezed
          ? _value.themedata
          : themedata // ignore: cast_nullable_to_non_nullable
              as ButtonThemeData,
      child: child == freezed
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget,
    ));
  }
}

/// @nodoc

class _$ButtonConfigRaised
    with DiagnosticableTreeMixin
    implements ButtonConfigRaised {
  const _$ButtonConfigRaised({required this.themedata, required this.child});

  @override
  final ButtonThemeData themedata;
  @override
  final Widget child;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonConfig.raised(themedata: $themedata, child: $child)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ButtonConfig.raised'))
      ..add(DiagnosticsProperty('themedata', themedata))
      ..add(DiagnosticsProperty('child', child));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ButtonConfigRaised &&
            (identical(other.themedata, themedata) ||
                const DeepCollectionEquality()
                    .equals(other.themedata, themedata)) &&
            (identical(other.child, child) ||
                const DeepCollectionEquality().equals(other.child, child)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(themedata) ^
      const DeepCollectionEquality().hash(child);

  @JsonKey(ignore: true)
  @override
  $ButtonConfigRaisedCopyWith<ButtonConfigRaised> get copyWith =>
      _$ButtonConfigRaisedCopyWithImpl<ButtonConfigRaised>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ButtonThemeData themedata, Widget child) raised,
    required TResult Function(ButtonThemeData themedata, Widget child) flat,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        flatIcon,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        raisedIcon,
  }) {
    return raised(themedata, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ButtonThemeData themedata, Widget child)? raised,
    TResult Function(ButtonThemeData themedata, Widget child)? flat,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        flatIcon,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        raisedIcon,
    required TResult orElse(),
  }) {
    if (raised != null) {
      return raised(themedata, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ButtonConfigRaised value) raised,
    required TResult Function(ButtonConfigFlat value) flat,
    required TResult Function(ButtonConfigFlatIcon value) flatIcon,
    required TResult Function(ButtonConfigRaisedIcon value) raisedIcon,
  }) {
    return raised(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ButtonConfigRaised value)? raised,
    TResult Function(ButtonConfigFlat value)? flat,
    TResult Function(ButtonConfigFlatIcon value)? flatIcon,
    TResult Function(ButtonConfigRaisedIcon value)? raisedIcon,
    required TResult orElse(),
  }) {
    if (raised != null) {
      return raised(this);
    }
    return orElse();
  }
}

abstract class ButtonConfigRaised implements ButtonConfig {
  const factory ButtonConfigRaised(
      {required ButtonThemeData themedata,
      required Widget child}) = _$ButtonConfigRaised;

  @override
  ButtonThemeData get themedata => throw _privateConstructorUsedError;
  @override
  Widget get child => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ButtonConfigRaisedCopyWith<ButtonConfigRaised> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ButtonConfigFlatCopyWith<$Res>
    implements $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigFlatCopyWith(
          ButtonConfigFlat value, $Res Function(ButtonConfigFlat) then) =
      _$ButtonConfigFlatCopyWithImpl<$Res>;
  @override
  $Res call({ButtonThemeData themedata, Widget child});
}

/// @nodoc
class _$ButtonConfigFlatCopyWithImpl<$Res>
    extends _$ButtonConfigCopyWithImpl<$Res>
    implements $ButtonConfigFlatCopyWith<$Res> {
  _$ButtonConfigFlatCopyWithImpl(
      ButtonConfigFlat _value, $Res Function(ButtonConfigFlat) _then)
      : super(_value, (v) => _then(v as ButtonConfigFlat));

  @override
  ButtonConfigFlat get _value => super._value as ButtonConfigFlat;

  @override
  $Res call({
    Object? themedata = freezed,
    Object? child = freezed,
  }) {
    return _then(ButtonConfigFlat(
      themedata: themedata == freezed
          ? _value.themedata
          : themedata // ignore: cast_nullable_to_non_nullable
              as ButtonThemeData,
      child: child == freezed
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget,
    ));
  }
}

/// @nodoc

class _$ButtonConfigFlat
    with DiagnosticableTreeMixin
    implements ButtonConfigFlat {
  const _$ButtonConfigFlat({required this.themedata, required this.child});

  @override
  final ButtonThemeData themedata;
  @override
  final Widget child;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonConfig.flat(themedata: $themedata, child: $child)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ButtonConfig.flat'))
      ..add(DiagnosticsProperty('themedata', themedata))
      ..add(DiagnosticsProperty('child', child));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ButtonConfigFlat &&
            (identical(other.themedata, themedata) ||
                const DeepCollectionEquality()
                    .equals(other.themedata, themedata)) &&
            (identical(other.child, child) ||
                const DeepCollectionEquality().equals(other.child, child)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(themedata) ^
      const DeepCollectionEquality().hash(child);

  @JsonKey(ignore: true)
  @override
  $ButtonConfigFlatCopyWith<ButtonConfigFlat> get copyWith =>
      _$ButtonConfigFlatCopyWithImpl<ButtonConfigFlat>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ButtonThemeData themedata, Widget child) raised,
    required TResult Function(ButtonThemeData themedata, Widget child) flat,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        flatIcon,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        raisedIcon,
  }) {
    return flat(themedata, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ButtonThemeData themedata, Widget child)? raised,
    TResult Function(ButtonThemeData themedata, Widget child)? flat,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        flatIcon,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        raisedIcon,
    required TResult orElse(),
  }) {
    if (flat != null) {
      return flat(themedata, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ButtonConfigRaised value) raised,
    required TResult Function(ButtonConfigFlat value) flat,
    required TResult Function(ButtonConfigFlatIcon value) flatIcon,
    required TResult Function(ButtonConfigRaisedIcon value) raisedIcon,
  }) {
    return flat(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ButtonConfigRaised value)? raised,
    TResult Function(ButtonConfigFlat value)? flat,
    TResult Function(ButtonConfigFlatIcon value)? flatIcon,
    TResult Function(ButtonConfigRaisedIcon value)? raisedIcon,
    required TResult orElse(),
  }) {
    if (flat != null) {
      return flat(this);
    }
    return orElse();
  }
}

abstract class ButtonConfigFlat implements ButtonConfig {
  const factory ButtonConfigFlat(
      {required ButtonThemeData themedata,
      required Widget child}) = _$ButtonConfigFlat;

  @override
  ButtonThemeData get themedata => throw _privateConstructorUsedError;
  @override
  Widget get child => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ButtonConfigFlatCopyWith<ButtonConfigFlat> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ButtonConfigFlatIconCopyWith<$Res>
    implements $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigFlatIconCopyWith(ButtonConfigFlatIcon value,
          $Res Function(ButtonConfigFlatIcon) then) =
      _$ButtonConfigFlatIconCopyWithImpl<$Res>;
  @override
  $Res call({ButtonThemeData themedata, Widget icon, Widget child});
}

/// @nodoc
class _$ButtonConfigFlatIconCopyWithImpl<$Res>
    extends _$ButtonConfigCopyWithImpl<$Res>
    implements $ButtonConfigFlatIconCopyWith<$Res> {
  _$ButtonConfigFlatIconCopyWithImpl(
      ButtonConfigFlatIcon _value, $Res Function(ButtonConfigFlatIcon) _then)
      : super(_value, (v) => _then(v as ButtonConfigFlatIcon));

  @override
  ButtonConfigFlatIcon get _value => super._value as ButtonConfigFlatIcon;

  @override
  $Res call({
    Object? themedata = freezed,
    Object? icon = freezed,
    Object? child = freezed,
  }) {
    return _then(ButtonConfigFlatIcon(
      themedata: themedata == freezed
          ? _value.themedata
          : themedata // ignore: cast_nullable_to_non_nullable
              as ButtonThemeData,
      icon: icon == freezed
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Widget,
      child: child == freezed
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget,
    ));
  }
}

/// @nodoc

class _$ButtonConfigFlatIcon
    with DiagnosticableTreeMixin
    implements ButtonConfigFlatIcon {
  const _$ButtonConfigFlatIcon(
      {required this.themedata, required this.icon, required this.child});

  @override
  final ButtonThemeData themedata;
  @override
  final Widget icon;
  @override
  final Widget child;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonConfig.flatIcon(themedata: $themedata, icon: $icon, child: $child)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ButtonConfig.flatIcon'))
      ..add(DiagnosticsProperty('themedata', themedata))
      ..add(DiagnosticsProperty('icon', icon))
      ..add(DiagnosticsProperty('child', child));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ButtonConfigFlatIcon &&
            (identical(other.themedata, themedata) ||
                const DeepCollectionEquality()
                    .equals(other.themedata, themedata)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.child, child) ||
                const DeepCollectionEquality().equals(other.child, child)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(themedata) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(child);

  @JsonKey(ignore: true)
  @override
  $ButtonConfigFlatIconCopyWith<ButtonConfigFlatIcon> get copyWith =>
      _$ButtonConfigFlatIconCopyWithImpl<ButtonConfigFlatIcon>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ButtonThemeData themedata, Widget child) raised,
    required TResult Function(ButtonThemeData themedata, Widget child) flat,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        flatIcon,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        raisedIcon,
  }) {
    return flatIcon(themedata, icon, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ButtonThemeData themedata, Widget child)? raised,
    TResult Function(ButtonThemeData themedata, Widget child)? flat,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        flatIcon,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        raisedIcon,
    required TResult orElse(),
  }) {
    if (flatIcon != null) {
      return flatIcon(themedata, icon, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ButtonConfigRaised value) raised,
    required TResult Function(ButtonConfigFlat value) flat,
    required TResult Function(ButtonConfigFlatIcon value) flatIcon,
    required TResult Function(ButtonConfigRaisedIcon value) raisedIcon,
  }) {
    return flatIcon(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ButtonConfigRaised value)? raised,
    TResult Function(ButtonConfigFlat value)? flat,
    TResult Function(ButtonConfigFlatIcon value)? flatIcon,
    TResult Function(ButtonConfigRaisedIcon value)? raisedIcon,
    required TResult orElse(),
  }) {
    if (flatIcon != null) {
      return flatIcon(this);
    }
    return orElse();
  }
}

abstract class ButtonConfigFlatIcon implements ButtonConfig {
  const factory ButtonConfigFlatIcon(
      {required ButtonThemeData themedata,
      required Widget icon,
      required Widget child}) = _$ButtonConfigFlatIcon;

  @override
  ButtonThemeData get themedata => throw _privateConstructorUsedError;
  Widget get icon => throw _privateConstructorUsedError;
  @override
  Widget get child => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ButtonConfigFlatIconCopyWith<ButtonConfigFlatIcon> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ButtonConfigRaisedIconCopyWith<$Res>
    implements $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigRaisedIconCopyWith(ButtonConfigRaisedIcon value,
          $Res Function(ButtonConfigRaisedIcon) then) =
      _$ButtonConfigRaisedIconCopyWithImpl<$Res>;
  @override
  $Res call({ButtonThemeData themedata, Widget icon, Widget child});
}

/// @nodoc
class _$ButtonConfigRaisedIconCopyWithImpl<$Res>
    extends _$ButtonConfigCopyWithImpl<$Res>
    implements $ButtonConfigRaisedIconCopyWith<$Res> {
  _$ButtonConfigRaisedIconCopyWithImpl(ButtonConfigRaisedIcon _value,
      $Res Function(ButtonConfigRaisedIcon) _then)
      : super(_value, (v) => _then(v as ButtonConfigRaisedIcon));

  @override
  ButtonConfigRaisedIcon get _value => super._value as ButtonConfigRaisedIcon;

  @override
  $Res call({
    Object? themedata = freezed,
    Object? icon = freezed,
    Object? child = freezed,
  }) {
    return _then(ButtonConfigRaisedIcon(
      themedata: themedata == freezed
          ? _value.themedata
          : themedata // ignore: cast_nullable_to_non_nullable
              as ButtonThemeData,
      icon: icon == freezed
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Widget,
      child: child == freezed
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget,
    ));
  }
}

/// @nodoc

class _$ButtonConfigRaisedIcon
    with DiagnosticableTreeMixin
    implements ButtonConfigRaisedIcon {
  const _$ButtonConfigRaisedIcon(
      {required this.themedata, required this.icon, required this.child});

  @override
  final ButtonThemeData themedata;
  @override
  final Widget icon;
  @override
  final Widget child;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonConfig.raisedIcon(themedata: $themedata, icon: $icon, child: $child)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ButtonConfig.raisedIcon'))
      ..add(DiagnosticsProperty('themedata', themedata))
      ..add(DiagnosticsProperty('icon', icon))
      ..add(DiagnosticsProperty('child', child));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ButtonConfigRaisedIcon &&
            (identical(other.themedata, themedata) ||
                const DeepCollectionEquality()
                    .equals(other.themedata, themedata)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.child, child) ||
                const DeepCollectionEquality().equals(other.child, child)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(themedata) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(child);

  @JsonKey(ignore: true)
  @override
  $ButtonConfigRaisedIconCopyWith<ButtonConfigRaisedIcon> get copyWith =>
      _$ButtonConfigRaisedIconCopyWithImpl<ButtonConfigRaisedIcon>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ButtonThemeData themedata, Widget child) raised,
    required TResult Function(ButtonThemeData themedata, Widget child) flat,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        flatIcon,
    required TResult Function(
            ButtonThemeData themedata, Widget icon, Widget child)
        raisedIcon,
  }) {
    return raisedIcon(themedata, icon, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ButtonThemeData themedata, Widget child)? raised,
    TResult Function(ButtonThemeData themedata, Widget child)? flat,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        flatIcon,
    TResult Function(ButtonThemeData themedata, Widget icon, Widget child)?
        raisedIcon,
    required TResult orElse(),
  }) {
    if (raisedIcon != null) {
      return raisedIcon(themedata, icon, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ButtonConfigRaised value) raised,
    required TResult Function(ButtonConfigFlat value) flat,
    required TResult Function(ButtonConfigFlatIcon value) flatIcon,
    required TResult Function(ButtonConfigRaisedIcon value) raisedIcon,
  }) {
    return raisedIcon(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ButtonConfigRaised value)? raised,
    TResult Function(ButtonConfigFlat value)? flat,
    TResult Function(ButtonConfigFlatIcon value)? flatIcon,
    TResult Function(ButtonConfigRaisedIcon value)? raisedIcon,
    required TResult orElse(),
  }) {
    if (raisedIcon != null) {
      return raisedIcon(this);
    }
    return orElse();
  }
}

abstract class ButtonConfigRaisedIcon implements ButtonConfig {
  const factory ButtonConfigRaisedIcon(
      {required ButtonThemeData themedata,
      required Widget icon,
      required Widget child}) = _$ButtonConfigRaisedIcon;

  @override
  ButtonThemeData get themedata => throw _privateConstructorUsedError;
  Widget get icon => throw _privateConstructorUsedError;
  @override
  Widget get child => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ButtonConfigRaisedIconCopyWith<ButtonConfigRaisedIcon> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AppleButtonConfigTearOff {
  const _$AppleButtonConfigTearOff();

  _AppleButtonConfig call({ButtonConfig? config}) {
    return _AppleButtonConfig(
      config: config,
    );
  }

  _AppleButtonConfigDark dark({Widget? label}) {
    return _AppleButtonConfigDark(
      label: label,
    );
  }

  _AppleButtonConfigLight light({Widget? label}) {
    return _AppleButtonConfigLight(
      label: label,
    );
  }
}

/// @nodoc
const $AppleButtonConfig = _$AppleButtonConfigTearOff();

/// @nodoc
mixin _$AppleButtonConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value) $default, {
    required TResult Function(_AppleButtonConfigDark value) dark,
    required TResult Function(_AppleButtonConfigLight value) light,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value)? $default, {
    TResult Function(_AppleButtonConfigDark value)? dark,
    TResult Function(_AppleButtonConfigLight value)? light,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppleButtonConfigCopyWith<$Res> {
  factory $AppleButtonConfigCopyWith(
          AppleButtonConfig value, $Res Function(AppleButtonConfig) then) =
      _$AppleButtonConfigCopyWithImpl<$Res>;
}

/// @nodoc
class _$AppleButtonConfigCopyWithImpl<$Res>
    implements $AppleButtonConfigCopyWith<$Res> {
  _$AppleButtonConfigCopyWithImpl(this._value, this._then);

  final AppleButtonConfig _value;
  // ignore: unused_field
  final $Res Function(AppleButtonConfig) _then;
}

/// @nodoc
abstract class _$AppleButtonConfigCopyWith<$Res> {
  factory _$AppleButtonConfigCopyWith(
          _AppleButtonConfig value, $Res Function(_AppleButtonConfig) then) =
      __$AppleButtonConfigCopyWithImpl<$Res>;
  $Res call({ButtonConfig? config});

  $ButtonConfigCopyWith<$Res>? get config;
}

/// @nodoc
class __$AppleButtonConfigCopyWithImpl<$Res>
    extends _$AppleButtonConfigCopyWithImpl<$Res>
    implements _$AppleButtonConfigCopyWith<$Res> {
  __$AppleButtonConfigCopyWithImpl(
      _AppleButtonConfig _value, $Res Function(_AppleButtonConfig) _then)
      : super(_value, (v) => _then(v as _AppleButtonConfig));

  @override
  _AppleButtonConfig get _value => super._value as _AppleButtonConfig;

  @override
  $Res call({
    Object? config = freezed,
  }) {
    return _then(_AppleButtonConfig(
      config: config == freezed
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
    ));
  }

  @override
  $ButtonConfigCopyWith<$Res>? get config {
    if (_value.config == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.config!, (value) {
      return _then(_value.copyWith(config: value));
    });
  }
}

/// @nodoc

class _$_AppleButtonConfig
    with DiagnosticableTreeMixin
    implements _AppleButtonConfig {
  const _$_AppleButtonConfig({this.config});

  @override
  final ButtonConfig? config;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppleButtonConfig(config: $config)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppleButtonConfig'))
      ..add(DiagnosticsProperty('config', config));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AppleButtonConfig &&
            (identical(other.config, config) ||
                const DeepCollectionEquality().equals(other.config, config)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(config);

  @JsonKey(ignore: true)
  @override
  _$AppleButtonConfigCopyWith<_AppleButtonConfig> get copyWith =>
      __$AppleButtonConfigCopyWithImpl<_AppleButtonConfig>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return $default(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value) $default, {
    required TResult Function(_AppleButtonConfigDark value) dark,
    required TResult Function(_AppleButtonConfigLight value) light,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value)? $default, {
    TResult Function(_AppleButtonConfigDark value)? dark,
    TResult Function(_AppleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _AppleButtonConfig implements AppleButtonConfig {
  const factory _AppleButtonConfig({ButtonConfig? config}) =
      _$_AppleButtonConfig;

  ButtonConfig? get config => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AppleButtonConfigCopyWith<_AppleButtonConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$AppleButtonConfigDarkCopyWith<$Res> {
  factory _$AppleButtonConfigDarkCopyWith(_AppleButtonConfigDark value,
          $Res Function(_AppleButtonConfigDark) then) =
      __$AppleButtonConfigDarkCopyWithImpl<$Res>;
  $Res call({Widget? label});
}

/// @nodoc
class __$AppleButtonConfigDarkCopyWithImpl<$Res>
    extends _$AppleButtonConfigCopyWithImpl<$Res>
    implements _$AppleButtonConfigDarkCopyWith<$Res> {
  __$AppleButtonConfigDarkCopyWithImpl(_AppleButtonConfigDark _value,
      $Res Function(_AppleButtonConfigDark) _then)
      : super(_value, (v) => _then(v as _AppleButtonConfigDark));

  @override
  _AppleButtonConfigDark get _value => super._value as _AppleButtonConfigDark;

  @override
  $Res call({
    Object? label = freezed,
  }) {
    return _then(_AppleButtonConfigDark(
      label: label == freezed
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc

class _$_AppleButtonConfigDark
    with DiagnosticableTreeMixin
    implements _AppleButtonConfigDark {
  const _$_AppleButtonConfigDark({this.label});

  @override
  final Widget? label;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppleButtonConfig.dark(label: $label)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppleButtonConfig.dark'))
      ..add(DiagnosticsProperty('label', label));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AppleButtonConfigDark &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(label);

  @JsonKey(ignore: true)
  @override
  _$AppleButtonConfigDarkCopyWith<_AppleButtonConfigDark> get copyWith =>
      __$AppleButtonConfigDarkCopyWithImpl<_AppleButtonConfigDark>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return dark(label);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(label);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value) $default, {
    required TResult Function(_AppleButtonConfigDark value) dark,
    required TResult Function(_AppleButtonConfigLight value) light,
  }) {
    return dark(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value)? $default, {
    TResult Function(_AppleButtonConfigDark value)? dark,
    TResult Function(_AppleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(this);
    }
    return orElse();
  }
}

abstract class _AppleButtonConfigDark implements AppleButtonConfig {
  const factory _AppleButtonConfigDark({Widget? label}) =
      _$_AppleButtonConfigDark;

  Widget? get label => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AppleButtonConfigDarkCopyWith<_AppleButtonConfigDark> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$AppleButtonConfigLightCopyWith<$Res> {
  factory _$AppleButtonConfigLightCopyWith(_AppleButtonConfigLight value,
          $Res Function(_AppleButtonConfigLight) then) =
      __$AppleButtonConfigLightCopyWithImpl<$Res>;
  $Res call({Widget? label});
}

/// @nodoc
class __$AppleButtonConfigLightCopyWithImpl<$Res>
    extends _$AppleButtonConfigCopyWithImpl<$Res>
    implements _$AppleButtonConfigLightCopyWith<$Res> {
  __$AppleButtonConfigLightCopyWithImpl(_AppleButtonConfigLight _value,
      $Res Function(_AppleButtonConfigLight) _then)
      : super(_value, (v) => _then(v as _AppleButtonConfigLight));

  @override
  _AppleButtonConfigLight get _value => super._value as _AppleButtonConfigLight;

  @override
  $Res call({
    Object? label = freezed,
  }) {
    return _then(_AppleButtonConfigLight(
      label: label == freezed
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc

class _$_AppleButtonConfigLight
    with DiagnosticableTreeMixin
    implements _AppleButtonConfigLight {
  const _$_AppleButtonConfigLight({this.label});

  @override
  final Widget? label;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AppleButtonConfig.light(label: $label)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AppleButtonConfig.light'))
      ..add(DiagnosticsProperty('label', label));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AppleButtonConfigLight &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(label);

  @JsonKey(ignore: true)
  @override
  _$AppleButtonConfigLightCopyWith<_AppleButtonConfigLight> get copyWith =>
      __$AppleButtonConfigLightCopyWithImpl<_AppleButtonConfigLight>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return light(label);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light(label);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value) $default, {
    required TResult Function(_AppleButtonConfigDark value) dark,
    required TResult Function(_AppleButtonConfigLight value) light,
  }) {
    return light(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AppleButtonConfig value)? $default, {
    TResult Function(_AppleButtonConfigDark value)? dark,
    TResult Function(_AppleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light(this);
    }
    return orElse();
  }
}

abstract class _AppleButtonConfigLight implements AppleButtonConfig {
  const factory _AppleButtonConfigLight({Widget? label}) =
      _$_AppleButtonConfigLight;

  Widget? get label => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AppleButtonConfigLightCopyWith<_AppleButtonConfigLight> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$GoogleButtonConfigTearOff {
  const _$GoogleButtonConfigTearOff();

  _GoogleButtonConfig call({ButtonConfig? config}) {
    return _GoogleButtonConfig(
      config: config,
    );
  }

  _GoogleButtonConfigDark dark({Widget? label}) {
    return _GoogleButtonConfigDark(
      label: label,
    );
  }

  _GoogleButtonConfigLight light({Widget? label}) {
    return _GoogleButtonConfigLight(
      label: label,
    );
  }
}

/// @nodoc
const $GoogleButtonConfig = _$GoogleButtonConfigTearOff();

/// @nodoc
mixin _$GoogleButtonConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value) $default, {
    required TResult Function(_GoogleButtonConfigDark value) dark,
    required TResult Function(_GoogleButtonConfigLight value) light,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value)? $default, {
    TResult Function(_GoogleButtonConfigDark value)? dark,
    TResult Function(_GoogleButtonConfigLight value)? light,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GoogleButtonConfigCopyWith<$Res> {
  factory $GoogleButtonConfigCopyWith(
          GoogleButtonConfig value, $Res Function(GoogleButtonConfig) then) =
      _$GoogleButtonConfigCopyWithImpl<$Res>;
}

/// @nodoc
class _$GoogleButtonConfigCopyWithImpl<$Res>
    implements $GoogleButtonConfigCopyWith<$Res> {
  _$GoogleButtonConfigCopyWithImpl(this._value, this._then);

  final GoogleButtonConfig _value;
  // ignore: unused_field
  final $Res Function(GoogleButtonConfig) _then;
}

/// @nodoc
abstract class _$GoogleButtonConfigCopyWith<$Res> {
  factory _$GoogleButtonConfigCopyWith(
          _GoogleButtonConfig value, $Res Function(_GoogleButtonConfig) then) =
      __$GoogleButtonConfigCopyWithImpl<$Res>;
  $Res call({ButtonConfig? config});

  $ButtonConfigCopyWith<$Res>? get config;
}

/// @nodoc
class __$GoogleButtonConfigCopyWithImpl<$Res>
    extends _$GoogleButtonConfigCopyWithImpl<$Res>
    implements _$GoogleButtonConfigCopyWith<$Res> {
  __$GoogleButtonConfigCopyWithImpl(
      _GoogleButtonConfig _value, $Res Function(_GoogleButtonConfig) _then)
      : super(_value, (v) => _then(v as _GoogleButtonConfig));

  @override
  _GoogleButtonConfig get _value => super._value as _GoogleButtonConfig;

  @override
  $Res call({
    Object? config = freezed,
  }) {
    return _then(_GoogleButtonConfig(
      config: config == freezed
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as ButtonConfig?,
    ));
  }

  @override
  $ButtonConfigCopyWith<$Res>? get config {
    if (_value.config == null) {
      return null;
    }

    return $ButtonConfigCopyWith<$Res>(_value.config!, (value) {
      return _then(_value.copyWith(config: value));
    });
  }
}

/// @nodoc

class _$_GoogleButtonConfig
    with DiagnosticableTreeMixin
    implements _GoogleButtonConfig {
  const _$_GoogleButtonConfig({this.config});

  @override
  final ButtonConfig? config;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GoogleButtonConfig(config: $config)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GoogleButtonConfig'))
      ..add(DiagnosticsProperty('config', config));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GoogleButtonConfig &&
            (identical(other.config, config) ||
                const DeepCollectionEquality().equals(other.config, config)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(config);

  @JsonKey(ignore: true)
  @override
  _$GoogleButtonConfigCopyWith<_GoogleButtonConfig> get copyWith =>
      __$GoogleButtonConfigCopyWithImpl<_GoogleButtonConfig>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return $default(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value) $default, {
    required TResult Function(_GoogleButtonConfigDark value) dark,
    required TResult Function(_GoogleButtonConfigLight value) light,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value)? $default, {
    TResult Function(_GoogleButtonConfigDark value)? dark,
    TResult Function(_GoogleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _GoogleButtonConfig implements GoogleButtonConfig {
  const factory _GoogleButtonConfig({ButtonConfig? config}) =
      _$_GoogleButtonConfig;

  ButtonConfig? get config => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$GoogleButtonConfigCopyWith<_GoogleButtonConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$GoogleButtonConfigDarkCopyWith<$Res> {
  factory _$GoogleButtonConfigDarkCopyWith(_GoogleButtonConfigDark value,
          $Res Function(_GoogleButtonConfigDark) then) =
      __$GoogleButtonConfigDarkCopyWithImpl<$Res>;
  $Res call({Widget? label});
}

/// @nodoc
class __$GoogleButtonConfigDarkCopyWithImpl<$Res>
    extends _$GoogleButtonConfigCopyWithImpl<$Res>
    implements _$GoogleButtonConfigDarkCopyWith<$Res> {
  __$GoogleButtonConfigDarkCopyWithImpl(_GoogleButtonConfigDark _value,
      $Res Function(_GoogleButtonConfigDark) _then)
      : super(_value, (v) => _then(v as _GoogleButtonConfigDark));

  @override
  _GoogleButtonConfigDark get _value => super._value as _GoogleButtonConfigDark;

  @override
  $Res call({
    Object? label = freezed,
  }) {
    return _then(_GoogleButtonConfigDark(
      label: label == freezed
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc

class _$_GoogleButtonConfigDark
    with DiagnosticableTreeMixin
    implements _GoogleButtonConfigDark {
  const _$_GoogleButtonConfigDark({this.label});

  @override
  final Widget? label;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GoogleButtonConfig.dark(label: $label)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GoogleButtonConfig.dark'))
      ..add(DiagnosticsProperty('label', label));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GoogleButtonConfigDark &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(label);

  @JsonKey(ignore: true)
  @override
  _$GoogleButtonConfigDarkCopyWith<_GoogleButtonConfigDark> get copyWith =>
      __$GoogleButtonConfigDarkCopyWithImpl<_GoogleButtonConfigDark>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return dark(label);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(label);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value) $default, {
    required TResult Function(_GoogleButtonConfigDark value) dark,
    required TResult Function(_GoogleButtonConfigLight value) light,
  }) {
    return dark(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value)? $default, {
    TResult Function(_GoogleButtonConfigDark value)? dark,
    TResult Function(_GoogleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(this);
    }
    return orElse();
  }
}

abstract class _GoogleButtonConfigDark implements GoogleButtonConfig {
  const factory _GoogleButtonConfigDark({Widget? label}) =
      _$_GoogleButtonConfigDark;

  Widget? get label => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$GoogleButtonConfigDarkCopyWith<_GoogleButtonConfigDark> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$GoogleButtonConfigLightCopyWith<$Res> {
  factory _$GoogleButtonConfigLightCopyWith(_GoogleButtonConfigLight value,
          $Res Function(_GoogleButtonConfigLight) then) =
      __$GoogleButtonConfigLightCopyWithImpl<$Res>;
  $Res call({Widget? label});
}

/// @nodoc
class __$GoogleButtonConfigLightCopyWithImpl<$Res>
    extends _$GoogleButtonConfigCopyWithImpl<$Res>
    implements _$GoogleButtonConfigLightCopyWith<$Res> {
  __$GoogleButtonConfigLightCopyWithImpl(_GoogleButtonConfigLight _value,
      $Res Function(_GoogleButtonConfigLight) _then)
      : super(_value, (v) => _then(v as _GoogleButtonConfigLight));

  @override
  _GoogleButtonConfigLight get _value =>
      super._value as _GoogleButtonConfigLight;

  @override
  $Res call({
    Object? label = freezed,
  }) {
    return _then(_GoogleButtonConfigLight(
      label: label == freezed
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc

class _$_GoogleButtonConfigLight
    with DiagnosticableTreeMixin
    implements _GoogleButtonConfigLight {
  const _$_GoogleButtonConfigLight({this.label});

  @override
  final Widget? label;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GoogleButtonConfig.light(label: $label)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GoogleButtonConfig.light'))
      ..add(DiagnosticsProperty('label', label));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GoogleButtonConfigLight &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(label);

  @JsonKey(ignore: true)
  @override
  _$GoogleButtonConfigLightCopyWith<_GoogleButtonConfigLight> get copyWith =>
      __$GoogleButtonConfigLightCopyWithImpl<_GoogleButtonConfigLight>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ButtonConfig? config) $default, {
    required TResult Function(Widget? label) dark,
    required TResult Function(Widget? label) light,
  }) {
    return light(label);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ButtonConfig? config)? $default, {
    TResult Function(Widget? label)? dark,
    TResult Function(Widget? label)? light,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light(label);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value) $default, {
    required TResult Function(_GoogleButtonConfigDark value) dark,
    required TResult Function(_GoogleButtonConfigLight value) light,
  }) {
    return light(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GoogleButtonConfig value)? $default, {
    TResult Function(_GoogleButtonConfigDark value)? dark,
    TResult Function(_GoogleButtonConfigLight value)? light,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light(this);
    }
    return orElse();
  }
}

abstract class _GoogleButtonConfigLight implements GoogleButtonConfig {
  const factory _GoogleButtonConfigLight({Widget? label}) =
      _$_GoogleButtonConfigLight;

  Widget? get label => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$GoogleButtonConfigLightCopyWith<_GoogleButtonConfigLight> get copyWith =>
      throw _privateConstructorUsedError;
}
